# Migration CLI and Project Setup

### Index

- [Development Environment Migration Flow](#Development Environment Migration Flow)

- [Setup](#Setup)
  - [Postgres](#Postgres)
  - [Knex](#Knex)
  - [Dotenv](#Dotenv)
- [Knex CLI](#Knex-CLI)
  - [Migration files](#Migration-files)
  - [Schema Builder](#Schema Builder)
  - [Create Table](#Create Table)
  - [Adding Column](#Adding Column)
- [Running Migration](#Running Migration)
- [Seeding](#Seeding)

---

### Development Environment Migration Flow

0. Design database structure before doing anything below

1. [Install and start DB](#Postgres)
2. [Install query builder](#Knex)
3. [Setup environment](#dotenv)
4. [Create migration file](#Migration files)
5. [Run migration file to create tables](#Running Migration)
6. [Seeding](#Seeding)

---

### Setup

#### Postgres

```bash
## Start postgresql server with:
$ sudo service postgresql start

## Access default user 'postgres' with all permission
$ sudo su postgres
[sudo] password for postgres: password

## To create a new database: 
$ createdb <DBname>
## To create a new database with utf-8 encoding instead of SQL_ASCII:
$ createdb newdb --encoding='utf-8' --locale=en_US.utf8 --template=template0
```

#### Knex

To install knex cli globally to allow us to use knex to generate a knex repository :

```bash
$ sudo npm install knex -g 
```

To create the project folder :

```bash
# Make folder myApp
$ mkdir myApp
$ cd myApp

# Init NPM repository
$ npm init

# Install knex to the NPM repository
$ npm install knex

# Run knex CLI to init the repo
$ knex init
```

The knex migration tool generates a file called `knexfile.js` which stores the config of your knex project.

Update the file accordingly.

```js
const dotenv = require("dotenv");
dotenv.config();

module.exports = {
  development: {
    debug: true,
    client: "postgresql",
    connection: {
      host: process.env.DB_HOST || "localhost",
      port: process.env.DB_PORT || "5432",
      database: process.env.DB_NAME,
      user: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: "knex_migrations"
    }
  },
  testing: {
    client: "postgresql",
    connection: {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.TEST_DB_NAME,
      user: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: "knex_migrations"
    }
  },
  staging: {
    client: "postgresql",
    connection: {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      user: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: "knex_migrations"
    }
  },

  production: {
    client: "postgresql",
    connection: {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      user: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    },
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: "knex_migrations"
    }
  }
};
```

Three different environments have been generated by default :

- `development` : It is the default environment for development. Therefore you have to input your development database information in this environment.
- `staging` : It is also called the `beta` or `testing` environment. It is normally the environment for your development team to do testing. You have to input the database information of the testing environment.
- `production`: It is the environment for your application in production. The database information should also accordingly be the production database information.

---

### Dotenv

- We will not want to place all sensitive material in the config file
- So we need to store them somewhere else and import them when needed
- We will use the `dotenv` package to store environmental variables

To install the `dotenv` package :

```bash
$ npm install dotenv
```

To use :

```js
// create a .env file
// place these inside
DB_NAME=test
DB_USERNAME=postgres
DB_PASSWORD=postgres
// *Please note that there is no space between and after the '=' sign
```

```js
// in knexfile.js , or any file that requires to import env. var
require('dotenv').config();
// environmental variables are now accessible at the object process.env

module.exports = {
  development: {
    client: 'postgresql',
    connection: {
      database: process.env.DB_NAME,
      user:     process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD
    },
    pool: { ........
```

---

### Knex CLI

Use `knex-cli` to generate migration file.

```bash
Usage: knex [options] [command]

Options:

  -V, --version      output the version number
  --debug            Run with debugging.
  --knexfile [path]  Specify the knexfile path.
  --cwd [path]       Specify the working directory.
  --env [name]       environment, default: process.env.NODE_ENV || development
  -h, --help         output usage information

Commands:

  init [options]                         Create a fresh knexfile.
  migrate:make [options] <name>          Create a named migration file.
  migrate:latest                         Run all migrations that have not yet been run.
  migrate:rollback                       Rollback the last set of migrations performed.
  migrate:currentVersion                 View the current version for the migration.
  seed:make [options] <name>             Create a named seed file.
  seed:run                               Run seed files.
```

#### Migration files

- Migrations are changes to the database schema, just like the revision control of a database
- Easily migrate older version of the database to the latest version

To create a new migration file :

```bash
# this command generates a new migration file with the name <Timestamp>_new-change-on-database.js
$ knex migrate:make new-change-on-database
```

##### Timestamp

- is the unix timestamp for the generation time
- migrations file are automatically ordered by the respective generation time
- READ ONLY

Inside migration File :

```js
exports.up = function(knex, Promise) {
	// 'forward' direction of the migration
	// will run when migrate:latest is called
};

exports.down = function(knex, Promise) {
	// 'backward' direction of the migration
	// will run when migrate:rollback is called
    // completely undo whatever done by the 'up' function    
};
```

`knex`

> connection object initialized using `knexfile.js`

`Promise`

> the Promise library object that allows you to use common Promise method like `Promise.all()`

#### Schema Builder

> In order to allow the developer to write the migration file properly, Knex actually comes with a schema builder which helps building [`DDL`](https://en.wikipedia.org/wiki/Data_definition_language)
>
> `DDL` are the part of SQL that is responsible for defining the structure of the data

#### Create Table

> Create a table with : 
>
> `knex.schema.createTable()`

```js
/* Example */
exports.up = function(knex,Promise){
  return knex.schema.createTable('users',(table)=>{
    table.increments();				// id column that auto-increments
    table.string("name");			// varchar column with the name name
    table.string("email");			// varchar column with the name email
    table.timestamps(false,true);	// created_at , updated_at columns which is updated automatically during creation
  });
}

exports.down = function(knex,Promise){
  return knex.schema.dropTable('users');	// drop the table to undo everything 
}
```

#### Adding Column

> Access table with :
>
> `knex.schema.table()`

```js
exports.up = function(knex, Promise) {
  return knex.schema.table('users',(table)=>{
    table.integer('group_id').unsigned();
    table.foreign('group_id').references('groups.id');
  });
};

exports.down = function(knex, Promise) {
  return knex.schema.table('users',(table)=>{
    table.dropForeign('group_id');
    table.dropColumn('group_id');
  })
};
```

> `table.integer('group_id')` adds an integer column called `group_id`to the table `users`
>
> `table.foreign('group_id')` adds a foreign constraint on the column `group_id`

---

### Running Migration

- keep track of migration files in git

#### Migrate to latest version

> **THERE IS NO COMMAND IN KNEX THAT ALLOWS DEVELOPER TO MIGRATE ONLY ONE MIGRATION**.

```bash
$ knex migrate:latest
```

#### Rollback migrations

> It is crucial to write also the `down`function correctly

```bash
$ knex migrate:rollback
```

#### Current Version

> Check what is the current version of migration

```bash
$ knex migrate:currentVersion
```

---

### Seeding

#### To generate a seeding file :

```bash
postgres $ knex seed:make <seed file name>
```

#### In the auto generated folder will find a new seed file :

```js
exports.seed = function(knex, Promise) {
  // Deletes ALL existing entries
  return knex('table_name').del()
    .then(function () {
      // Inserts seed entries
      return knex('table_name').insert([
        {colName: 'rowValue1'},
        {colName: 'rowValue2'},
        {colName: 'rowValue3'}
      ]);
    });
    // chain .then() here to keep seeding more tables
};
```

#### To seed multiple tables

- chain up the knex function with more `.then()`
- or create another seed file

